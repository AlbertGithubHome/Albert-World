# 41.缺失的第一个正数

41. 缺失的第一个正数

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。



示例 1:

输入: [1,2,0]
输出: 3

示例 2:

输入: [3,4,-1,1]
输出: 2

示例 3:

输入: [7,8,9,11,12]
输出: 1



提示：

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
通过次数65,088
提交次数164,633
在真实的面试中遇到过这道题？
贡献者

### 解题思路
提交失败一次，漏了一个必须修改成负数的细节，修改成负数就是为了做个标记，其实不必非得改成负数，理解了这个标记算法，可以把val改成(val + N)，只不过这样改判断的时候会多几步，但是也可以实现的

### 代码

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int m = nums.size();
        for (auto& n : nums) if (n <= 0) n = m + 1;
        for (auto& n : nums) {
            int an = abs(n);
            if (an <= m) nums[an-1] = -abs(nums[an-1]);
        }
        for (int i = 0; i < m; ++i) if (nums[i] > 0) return i + 1;
        return m + 1;
    }
};
```

### 提交記錄

```
执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
内存消耗：6.6 MB, 在所有 C++ 提交中击败了100.00% 的用户
```