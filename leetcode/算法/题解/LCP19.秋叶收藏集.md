# LCP19.秋叶收藏集

LCP 19. 秋叶收藏集

小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。

示例 1：

    输入：leaves = "rrryyyrryyyrr"

    输出：2

    解释：调整两次，将中间的两片红叶替换成黄叶，得到 "rrryyyyyyyyrr"

示例 2：

    输入：leaves = "ryr"

    输出：0

    解释：已符合要求，不需要额外操作

提示：

    3 <= leaves.length <= 10^5
    leaves 中只包含字符 'r' 和字符 'y'

通过次数1,370
提交次数7,619
在真实的面试中遇到过这道题？
贡献者

### 解题思路
和大佬没法比，赛后学习的，给之后的状态转移提个醒，一步步dp就好了，注意边界
3种状态变化，从0开始改成全红所需步数、从1开始改成黄色所需步数、从2开始改成红色所需步数
这样处理完肯定是符合条件的状态，所以dp[2][n-1]就是结果

当然这代码可以dp压缩，为了以后可以快速读懂，还是保留最原始的吧

### 代码

```cpp
class Solution {
public:
    int minimumOperations(string leaves) {
        int n = leaves.size();
        vector<vector<int>> dp(3, vector<int>(n, 0));

        for (int i = 0; i < n; i++) {
            // 从0开始改成全红所需步数
            dp[0][i] = (i < 1 ? 0 : dp[0][i-1]) + (leaves[i] != 'r');

            // 从1开始改成黄色所需步数
            dp[1][i] = i < 1 ? dp[0][i] : min(dp[0][i-1], dp[1][i-1]) + (leaves[i] != 'y');

            // 从2开始改成红色所需步数
            dp[2][i] = i < 2 ? dp[1][i] : min(dp[1][i-1], dp[2][i-1]) + (leaves[i] != 'r');
        }

        return dp[2][n-1];
    }
};
```

![图片.png](https://pic.leetcode-cn.com/1600005873-UgdQlx-%E5%9B%BE%E7%89%87.png)
